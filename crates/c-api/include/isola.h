#ifndef _ISOLA_H_
#define _ISOLA_H_

/* Don't modify this file manually. It is autogenerated by cbindgen. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

typedef enum isola_error_code {
  ISOLA_ERROR_CODE_OK = 0,
  ISOLA_ERROR_CODE_INVALID_ARGUMENT = 1,
  ISOLA_ERROR_CODE_INTERNAL = 2,
  ISOLA_ERROR_CODE_STREAM_FULL = 3,
  ISOLA_ERROR_CODE_STREAM_CLOSED = 4,
} isola_error_code;

typedef enum isola_callback_event {
  ISOLA_CALLBACK_EVENT_RESULT_JSON = 0,
  ISOLA_CALLBACK_EVENT_END_JSON = 4,
  ISOLA_CALLBACK_EVENT_STDOUT = 1,
  ISOLA_CALLBACK_EVENT_STDERR = 2,
  ISOLA_CALLBACK_EVENT_ERROR = 3,
  ISOLA_CALLBACK_EVENT_LOG = 5,
} isola_callback_event;

typedef enum isola_argument_type {
  ISOLA_ARGUMENT_TYPE_JSON = 0,
  ISOLA_ARGUMENT_TYPE_JSON_STREAM = 1,
} isola_argument_type;

typedef struct isola_context_handle isola_context_handle;

/**
 * Opaque handle for an in-flight HTTP response.
 *
 * The C side drives the response through three phases:
 * 1. `isola_http_response_body_start` — deliver status and headers
 * 2. `isola_http_response_body_push` — deliver body chunks (zero or more)
 * 3. `isola_http_response_body_close` — signal EOF and free the handle
 */
typedef struct isola_http_response_body isola_http_response_body;

typedef struct isola_sandbox_handle isola_sandbox_handle;

typedef struct isola_stream_handle isola_stream_handle;

/**
 * C-compatible HTTP header.
 */
typedef struct isola_http_header {
  const uint8_t *name;
  size_t name_len;
  const uint8_t *value;
  size_t value_len;
} isola_http_header;

/**
 * C-compatible HTTP request passed to the handler callback.
 */
typedef struct isola_http_request {
  const char *method;
  const char *url;
  const struct isola_http_header *headers;
  size_t headers_len;
  const uint8_t *body;
  size_t body_len;
} isola_http_request;

/**
 * Unified vtable for sandbox event handling and optional HTTP support.
 *
 * - `on_event` is required.
 * - `http_request` is optional (NULL to disable HTTP).
 */
typedef struct isola_sandbox_handler_vtable {
  /**
   * Called for output events (results, logs, stdout/stderr).
   */
  void (*on_event)(enum isola_callback_event, const uint8_t*, size_t, void*);
  /**
   * Called to initiate an HTTP request.
   *
   * The callback should return immediately. The `response_body` handle
   * is Rust-owned; the C side completes the response asynchronously:
   *
   * 1. `isola_http_response_body_start(response_body, status)` — once
   *    headers arrive.
   * 2. `isola_http_response_body_push(response_body, data, len)` — for each
   *    body chunk.
   * 3. `isola_http_response_body_close(response_body)` — to signal EOF and
   *    free the handle.
   */
  enum isola_error_code (*http_request)(const struct isola_http_request *request,
                                        struct isola_http_response_body *response_body,
                                        void *user_data);
} isola_sandbox_handler_vtable;

typedef struct isola_blob {
  const uint8_t *data;
  size_t len;
} isola_blob;

typedef union isola_argument_value {
  struct isola_blob data;
  const struct isola_stream_handle *stream;
} isola_argument_value;

typedef struct isola_argument {
  enum isola_argument_type type;
  const char *name;
  union isola_argument_value value;
} isola_argument;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new isola context with the specified number of threads.
 *
 * # Safety
 *
 * The caller must ensure that `out_context` is a valid pointer to an
 * uninitialized `Box<ContextHandle>`.
 */
enum isola_error_code isola_context_create(int nr_thread,
                                           struct isola_context_handle **out_context);

/**
 * Initializes the isola context with the specified path.
 *
 * # Safety
 *
 * The caller must ensure that `path` is a valid, null-terminated C string.
 */
enum isola_error_code isola_context_initialize(struct isola_context_handle *ctx, const char *path);

/**
 * Sets a configuration value for the isola context.
 *
 * # Safety
 *
 * The caller must ensure that both `key` and `value` are valid,
 * null-terminated C strings.
 */
enum isola_error_code isola_context_config_set(struct isola_context_handle *ctx,
                                               const char *key,
                                               const char *value);

void isola_context_destroy(struct isola_context_handle *_ctx);

/**
 * Creates a new sandbox instance from the context.
 *
 * # Safety
 *
 * The caller must ensure that `out_sandbox` is a valid pointer to an
 * uninitialized `Box<SandboxHandle>`.
 */
enum isola_error_code isola_sandbox_create(struct isola_context_handle *ctx,
                                           struct isola_sandbox_handle **out_sandbox);

void isola_sandbox_destroy(struct isola_sandbox_handle *_sandbox);

/**
 * Sets a configuration value for the sandbox.
 *
 * # Safety
 *
 * The caller must ensure that both `key` and `value` are valid,
 * null-terminated C strings.
 */
enum isola_error_code isola_sandbox_set_config(struct isola_sandbox_handle *sandbox,
                                               const char *key,
                                               const char *value);

/**
 * Sets the handler vtable on a sandbox.
 *
 * The vtable is copied; the caller may free it after this call returns.
 * Must be called exactly once, before `isola_sandbox_start`.
 *
 * # Safety
 *
 * `vtable` must point to a valid `SandboxHandlerVtable`.
 */
enum isola_error_code isola_sandbox_set_handler(struct isola_sandbox_handle *sandbox,
                                                const struct isola_sandbox_handler_vtable *vtable,
                                                void *user_data);

enum isola_error_code isola_sandbox_start(struct isola_sandbox_handle *sandbox);

/**
 * Loads a script into the sandbox.
 *
 * # Safety
 *
 * The caller must ensure that `input` is a valid, null-terminated C string.
 */
enum isola_error_code isola_sandbox_load_script(struct isola_sandbox_handle *sandbox,
                                                const char *input,
                                                uint64_t timeout_in_ms);

/**
 * Runs a function in the sandbox with the specified arguments.
 *
 * # Safety
 *
 * The caller must ensure that:
 * - `func` is a valid, null-terminated C string
 * - `args` is a valid pointer to an array of `Argument` structs of length
 *   `args_len`
 * - Each `Argument` in the array has valid pointers and data
 *
 * # Panics
 *
 * This function may panic if argument names contain invalid UTF-8 sequences.
 */
enum isola_error_code isola_sandbox_run(struct isola_sandbox_handle *sandbox,
                                        const char *func,
                                        const struct isola_argument *args,
                                        size_t args_len,
                                        uint64_t timeout_in_ms);

/**
 * Creates a new stream handle for streaming arguments.
 *
 * # Safety
 *
 * The caller must ensure that `out_stream` is a valid pointer to an
 * uninitialized `Box<StreamHandle>`.
 */
enum isola_error_code isola_stream_create(struct isola_stream_handle **out_stream);

/**
 * Pushes data to a stream.
 *
 * # Safety
 *
 * The caller must ensure that `data` points to a valid buffer of length `len`.
 *
 * # Parameters
 *
 * * `blocking` - If non-zero, blocks until space is available in the channel.
 *   If zero, returns immediately with an error if the channel is full.
 */
enum isola_error_code isola_stream_push(const struct isola_stream_handle *stream,
                                        const uint8_t *data,
                                        size_t len,
                                        int blocking);

/**
 * Signals the end of a stream.
 *
 * After calling this function, no more data can be pushed to the stream.
 */
enum isola_error_code isola_stream_end(struct isola_stream_handle *_stream);

void isola_stream_destroy(struct isola_stream_handle *_stream);

/**
 * Delivers the HTTP status code and response headers.
 *
 * Must be called exactly once per handle, before any
 * `isola_http_response_body_push` calls.
 *
 * The header data is copied; the caller may free the array after this
 * call returns.
 *
 * # Safety
 *
 * - `body` must be a live handle obtained from an `http_request` callback.
 * - `headers` must point to a valid array of `headers_len` elements (may be
 *   NULL if `headers_len` is 0).
 */
enum isola_error_code isola_http_response_body_start(const struct isola_http_response_body *body,
                                                     uint16_t status,
                                                     const struct isola_http_header *headers,
                                                     size_t headers_len);

/**
 * Pushes a chunk of response body data.
 *
 * May be called from any thread. Blocks if the internal channel is full.
 *
 * # Safety
 *
 * - `body` must be a live handle obtained from an `http_request` callback.
 * - `data` must point to a valid buffer of `len` bytes.
 */
enum isola_error_code isola_http_response_body_push(const struct isola_http_response_body *body,
                                                    const uint8_t *data,
                                                    size_t len);

/**
 * Signals EOF and frees the response body handle.
 *
 * Must be called exactly once per handle, even if no data was pushed.
 *
 * # Safety
 *
 * `body` must be a live handle obtained from an `http_request` callback.
 * After this call the pointer is invalid.
 */
void isola_http_response_body_close(struct isola_http_response_body *body);

const char *isola_last_error(void);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* _ISOLA_H_ */
