#![expect(
    clippy::needless_for_each,
    reason = "generated by utoipa::OpenApi derive macro"
)]

use std::collections::BTreeMap;

use axum::Json;
use serde::{Deserialize, Serialize};
use utoipa::{OpenApi, ToSchema};

use crate::routes::Runtime;

const fn default_timeout() -> u64 {
    30000
}

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct OpenApiExecuteRequest {
    pub runtime: Runtime,
    pub script: String,
    #[serde(default)]
    pub prelude: String,
    pub function: String,
    #[serde(default)]
    #[schema(value_type = Vec<Object>)]
    pub args: Vec<serde_json::Value>,
    #[serde(default)]
    #[schema(value_type = Object)]
    pub kwargs: BTreeMap<String, serde_json::Value>,
    #[serde(default = "default_timeout")]
    pub timeout_ms: u64,
    #[serde(default)]
    pub trace: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct OpenApiExecuteResponse {
    #[schema(value_type = Object)]
    pub result: serde_json::Value,
    #[serde(default)]
    #[schema(value_type = Vec<Object>)]
    pub traces: Vec<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct OpenApiErrorResponse {
    pub error: OpenApiHttpError,
}

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct OpenApiHttpError {
    pub code: OpenApiErrorCode,
    pub message: String,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, ToSchema)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum OpenApiErrorCode {
    InvalidRequest,
    ScriptError,
    Timeout,
    Cancelled,
    Internal,
}

#[derive(OpenApi)]
#[openapi(
    paths(
        super::execute::execute_sync,
        super::execute::execute_stream,
        super::websocket::ws_execute,
        openapi_json
    ),
    components(
        schemas(
            Runtime,
            OpenApiExecuteRequest,
            OpenApiExecuteResponse,
            OpenApiErrorResponse,
            OpenApiHttpError,
            OpenApiErrorCode,
        )
    ),
    tags(
        (name = "Execute", description = "Sandbox execution endpoints"),
        (name = "Meta", description = "Server metadata endpoints")
    )
)]
pub struct ApiDoc;

#[utoipa::path(
    get,
    path = "/openapi.json",
    responses(
        (status = 200, description = "OpenAPI document in JSON")
    ),
    operation_id = "openApiJson",
    tag = "Meta"
)]
pub async fn openapi_json() -> Json<utoipa::openapi::OpenApi> {
    Json(ApiDoc::openapi())
}

#[cfg(test)]
mod tests {
    use utoipa::OpenApi;

    use super::ApiDoc;

    #[test]
    fn generated_openapi_includes_routes_and_required_function() {
        let doc = serde_json::to_value(ApiDoc::openapi()).expect("openapi must serialize");
        let paths = doc
            .get("paths")
            .and_then(serde_json::Value::as_object)
            .expect("paths must exist");

        assert!(paths.contains_key("/v1/execute"));
        assert!(paths.contains_key("/v1/execute/stream"));
        assert!(paths.contains_key("/v1/execute/ws"));
        assert!(paths.contains_key("/openapi.json"));

        let required = doc
            .pointer("/components/schemas/OpenApiExecuteRequest/required")
            .and_then(serde_json::Value::as_array)
            .expect("OpenApiExecuteRequest.required must exist");
        assert!(required.iter().any(|field| field == "runtime"));
        assert!(required.iter().any(|field| field == "function"));
    }
}
