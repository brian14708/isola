#![allow(clippy::same_length_and_capacity)] // Generated by wit_bindgen::generate! macro

mod body_buffer;
pub mod future;
pub mod http;
mod logging;
mod serde;

use std::cell::RefCell;

use self::{
    exports::isola::script::runtime, future::PendingOp, isola::script::host,
    wasi::io::streams::StreamError,
};
use crate::{
    error::Error,
    script::{InputValue, Scope},
    serde as js_serde,
};

wit_bindgen::generate!({
    world: "sandbox",
    path: "../isola/wit",
    generate_all,
});

#[cfg(target_arch = "wasm32")]
export!(Global);

pub struct Global;

impl runtime::Guest for Global {
    fn initialize(preinit: bool, prelude: Option<String>) {
        GLOBAL_SCOPE.with(|scope| {
            let mut scope = scope.borrow_mut();
            if scope.is_none() {
                const ASYNC_JS: &str = include_str!("../../js/sandbox/async.js");
                const WINTERTC_ABORT_JS: &str = include_str!("../../js/sandbox/wintertc_abort.js");
                const WINTERTC_HTTP_JS: &str = include_str!("../../js/sandbox/wintertc_http.js");

                let s = Scope::new();

                // Register native bridge modules as globals
                s.context().with(|ctx| {
                    self::serde::register(&ctx);
                    self::logging::register(&ctx);
                    self::http::register(&ctx);
                    register_sys_module(&ctx);
                    // future::register_js must come after register_sys_module
                    // because it reads _isola_sys from globals
                    self::future::register_js(&ctx);
                });

                // Load JS-side async infrastructure and HTTP platform wrappers.
                // async.js must come before wintertc_http.js (uses _isola_async._wait).
                // async.js must come after register_sys_module (wraps
                // _isola_sys.hostcall/sleep).
                s.load_script(ASYNC_JS).unwrap();
                s.load_script(WINTERTC_ABORT_JS).unwrap();
                s.load_script(WINTERTC_HTTP_JS).unwrap();

                if let Some(prelude) = prelude {
                    s.load_script(&prelude).unwrap();
                }
                scope.replace(s);
            }
        });

        if preinit {
            #[link(wasm_import_module = "wasi_snapshot_preview1")]
            unsafe extern "C" {
                #[cfg_attr(target_arch = "wasm32", link_name = "reset_adapter_state")]
                fn reset_adapter_state();
            }

            #[link(wasm_import_module = "env")]
            unsafe extern "C" {
                #[cfg_attr(target_arch = "wasm32", link_name = "__wasilibc_reset_preopens")]
                fn wasilibc_reset_preopens();
            }

            unsafe {
                reset_adapter_state();
                wasilibc_reset_preopens();
            }
        }
    }

    fn eval_script(script: String) -> Result<(), runtime::Error> {
        GLOBAL_SCOPE.with_borrow(|sandbox| {
            sandbox.as_ref().map_or_else(
                || Err(Error::UnexpectedError("Sandbox not initialized").into()),
                |sandbox| {
                    sandbox
                        .load_script(&script)
                        .map_err(Into::<runtime::Error>::into)
                },
            )
        })
    }

    fn eval_file(path: String) -> Result<(), runtime::Error> {
        GLOBAL_SCOPE.with_borrow(|sandbox| {
            sandbox.as_ref().map_or_else(
                || Err(Error::UnexpectedError("Sandbox not initialized").into()),
                |sandbox| {
                    sandbox
                        .load_file(&path)
                        .map_err(Into::<runtime::Error>::into)
                },
            )
        })
    }

    fn call_func(func: String, args: Vec<runtime::Argument>) -> Result<(), runtime::Error> {
        GLOBAL_SCOPE.with_borrow(|sandbox| {
            sandbox.as_ref().map_or_else(
                || Err(Error::UnexpectedError("Sandbox not initialized").into()),
                |sandbox| {
                    let mut positional = vec![];
                    let mut named = vec![];
                    for arg in args {
                        let runtime::Argument { name, value } = arg;
                        let value = match value {
                            isola::script::host::Value::Cbor(s) => InputValue::Cbor(s.into()),
                            isola::script::host::Value::CborIterator(e) => {
                                InputValue::Iter(collect_stream_arg(&e)?)
                            }
                        };
                        if let Some(name) = name {
                            named.push((name.into(), value));
                        } else {
                            positional.push(value);
                        }
                    }
                    sandbox
                        .run(&func, positional, named, |emit_type, data| {
                            isola::script::host::blocking_emit(emit_type, data);
                        })
                        .map_err(Into::<runtime::Error>::into)
                },
            )
        })
    }
}

fn collect_stream_arg(iter: &host::ValueIterator) -> Result<Vec<Vec<u8>>, runtime::Error> {
    let mut items = Vec::new();
    loop {
        match iter.blocking_read() {
            Ok(cbor) => items.push(cbor),
            Err(StreamError::Closed) => return Ok(items),
            Err(StreamError::LastOperationFailed(e)) => {
                return Err(runtime::Error {
                    code: runtime::ErrorCode::Aborted,
                    message: e.to_debug_string(),
                });
            }
        }
    }
}

fn register_sys_module(ctx: &rquickjs::Ctx<'_>) {
    let globals = ctx.globals();

    let sys = rquickjs::Object::new(ctx.clone()).unwrap();

    // _isola_sys.emit(obj) - emit a partial result
    sys.set(
        "emit",
        rquickjs::Function::new(ctx.clone(), js_sys_emit).unwrap(),
    )
    .unwrap();

    // _isola_sys.hostcall(type, payload) -> handle: u32
    // Returns a pollable handle. Use with _isola_async._wait() +
    // _finish_hostcall().
    sys.set(
        "hostcall",
        rquickjs::Function::new(ctx.clone(), js_sys_hostcall).unwrap(),
    )
    .unwrap();

    // _isola_sys._finish_hostcall(handle) -> value
    // Retrieves the result of a completed hostcall.
    sys.set(
        "_finish_hostcall",
        rquickjs::Function::new(ctx.clone(), js_sys_finish_hostcall).unwrap(),
    )
    .unwrap();

    // _isola_sys.monotonic() - monotonic clock in seconds
    sys.set(
        "monotonic",
        rquickjs::Function::new(ctx.clone(), || -> f64 {
            use std::time::Duration;
            Duration::from_nanos(wasi::clocks::monotonic_clock::now()).as_secs_f64()
        })
        .unwrap(),
    )
    .unwrap();

    // _isola_sys.sleep(duration_secs) -> handle: u32
    // Returns a pollable handle. Use with _isola_async._wait().
    sys.set(
        "sleep",
        rquickjs::Function::new(ctx.clone(), |duration: f64| -> u32 {
            use std::time::Duration;
            let nanos = u64::try_from(Duration::from_secs_f64(duration).as_nanos())
                .expect("duration is too large");
            let pollable = wasi::clocks::monotonic_clock::subscribe_duration(nanos);
            future::register(pollable, PendingOp::Sleep)
        })
        .unwrap(),
    )
    .unwrap();

    globals.set("_isola_sys", sys).unwrap();
}

fn js_sys_emit<'js>(_ctx: rquickjs::Ctx<'js>, val: rquickjs::Value<'js>) -> rquickjs::Result<()> {
    js_serde::js_to_cbor_emit(
        val,
        isola::script::host::EmitType::PartialResult,
        isola::script::host::blocking_emit,
    )
    .map_err(|e| rquickjs::Error::new_from_js_message("value", "cbor", &e))?;
    Ok(())
}

/// Start a hostcall (non-blocking). Returns a pollable handle.
#[allow(clippy::needless_pass_by_value)]
fn js_sys_hostcall(
    _ctx: rquickjs::Ctx<'_>,
    call_type: String,
    payload: rquickjs::Value<'_>,
) -> rquickjs::Result<u32> {
    let cbor_payload = js_serde::js_to_cbor(payload)
        .map_err(|e| rquickjs::Error::new_from_js_message("value", "cbor", &e))?;
    let future_hostcall = isola::script::host::hostcall(&call_type, &cbor_payload);
    let pollable = future_hostcall.subscribe();
    let handle = future::register(pollable, PendingOp::Hostcall(future_hostcall));
    Ok(handle)
}

/// Retrieve the result of a completed hostcall.
#[allow(clippy::needless_pass_by_value)]
fn js_sys_finish_hostcall(
    ctx: rquickjs::Ctx<'_>,
    handle: u32,
) -> rquickjs::Result<rquickjs::Value<'_>> {
    future::finish_hostcall(&ctx, handle)
}

thread_local! {
    static GLOBAL_SCOPE: RefCell<Option<Scope>> = const { RefCell::new(None) };
}

impl std::io::Write for wasi::io::streams::OutputStream {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        let n = loop {
            match self.check_write().map(std::num::NonZeroU64::new) {
                Ok(Some(n)) => {
                    break n;
                }
                Ok(None) => {
                    self.subscribe().block();
                }
                Err(wasi::io::streams::StreamError::Closed) => return Ok(0),
                Err(wasi::io::streams::StreamError::LastOperationFailed(e)) => {
                    return Err(std::io::Error::other(e.to_debug_string()));
                }
            }
        };
        let n = n.get().try_into().map_err(std::io::Error::other)?;
        let n = buf.len().min(n);
        Self::write(self, &buf[..n]).map_err(|e| match e {
            wasi::io::streams::StreamError::Closed => std::io::ErrorKind::UnexpectedEof.into(),
            wasi::io::streams::StreamError::LastOperationFailed(e) => {
                std::io::Error::other(e.to_debug_string())
            }
        })?;
        Ok(n)
    }

    fn flush(&mut self) -> std::io::Result<()> {
        self.blocking_flush().map_err(std::io::Error::other)
    }
}
